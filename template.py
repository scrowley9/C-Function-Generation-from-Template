import json
import argparse
import os

def print_error_and_exit(error_string):
    print(error_string)
    exit(1)

def does_file_exist(path):
    return os.path.exists(path)


####################################################################################################
####################################### CLASSES ####################################################
####################################################################################################

# Function Argument Class
class Argument:
    def __init__(self, arg_name, arg_type):
        self.arg_name = arg_name
        self.arg_type = arg_type

    def get_arg_name(self):
        return self.arg_name

    def get_arg_type(self):
        return self.arg_type


# Function Template Class
class Template:

    # c_file_path -- Type: String
    # h_file_path -- Type: String
    # return_type -- Type: String
    # args -- Type: List of Arg class
    # function_names -- Type: List of Strings
    def __init__(self, c_file_path, h_file_path, return_type, args, function_names, extern_flag):
        self.c_file_path = c_file_path
        self.h_file_path = h_file_path
        self.return_type = return_type
        self.function_names = function_names
        self.extern_flag = extern_flag

        self.args = []
        self.headers = [] # List of function headers as strings

        # Populate list with arg objects
        for e in args:
            self.args.append(Argument(e[0], e[1]))

    # return true if template function is extern, false if static
    def is_extern(self):
        return self.extern_flag == "1"

    # Function Names are the only thing different
    # Function Header format is the same otherwise
    def get_header(self, func_name):
        header = self.return_type + " " + func_name + "("

        # Append args to string
        for index, arg in enumerate(self.args):
            header += "" + arg.get_arg_type() + " " + arg.get_arg_name()
            if index != (len(self.args)-1):
                header += ", "
        
        header += ")"
        return header
    
    # Create List of function strings
    def generate_function_header_list(self):
        # Loop over function names and append to headers list
        for name in self.function_names:
            func = self.get_header(name)
            self.headers.append(func)

        return self.headers        

    # toString Override method
    def __str__(self):
        string_format = """C File: %s\nH File: %s\nFunctions: %s\nReturn Type:%s\n"""
        """return_type"""
        return string_format % (self.c_file_path, self.h_file_path, self.function_names)

####################################################################################################
####################################################################################################
####################################################################################################

# Append to the end of a file -- Wrap this in a try/except block when using this function
# @param: preceding_str -- String you want preceding the function header (Ex: "extern", "static")
# @param: following_str -- String you want immediatley following function header (Ex: "{}", ";")
def append_to_file(append_file_path, preceding_str, headers, following_str):
        # NOTE: "with" keyword causes file to auto close when done
        with open(append_file_path, "a+") as app_file:
            app_file.write("/******* Functions Generated By Template Script *******/\n")

            # Append header to end of H file
            for func_header in headers:
                app_file.write(preceding_str+func_header+following_str+"\n")

# Append functions from template to C/H file
def output_functions_to_program_files(headers, template):

    # Check if BOTH c & h files exist
    if does_file_exist(template.c_file_path) is False:
        print("C File: " + template.c_file_path + " -- Does NOT Exist")
        return
    if does_file_exist(template.h_file_path) is False:
        print("H File: " + template.h_file_path + " -- Does NOT Exist")
        return 

    # Try to write out to h file: extern function header
    try:
            if template.is_extern() is True:
                append_to_file(template.h_file_path, "extern ", headers, ";")
                append_to_file(template.c_file_path, "", headers, "{\n\n}")
            else:
                append_to_file(template.c_file_path, "static", headers, "{\n\n}")
    except Exception as exc:
        print_error_and_exit("Exception while appending functions to C & H files: " + exc)

    # TODO: Add include statement to C file -- Parse file for #include "get_file_name_from_path(template.h_file_path)"
    


####################################################################################################
####################################################################################################
####################################################################################################

def get_file_name_from_path(path):
    if path is None: return None
    path_list_length = len(path.split("/"))
    return path.split("/")[path_list_length-1]

####################################################################################################
####################################################################################################
####################################################################################################

def create_template_objects_from_json(json_data, file_name):
    # Select Template Arrray Out of JSON
    temp = json_data["templates"]

    # Template List
    template_objects = []

    # Loop through template dictionaries
    try:
        for index, e in enumerate(temp):
            template_objects.append(Template(e["c_file"],
                                                                        e["h_file"],
                                                                        e["return_type"],
                                                                        e["args"],
                                                                        e["function_names"],
                                                                        e["extern"]))
    except Exception as exc:
        print_error_and_exit("JSON Format Exception: " + str(exc) + "\nJSON File Name: " + file_name +
                                            "\nTemplate Number: " + str(index))

    # Return template objects as a list
    return template_objects

####################################################################################################
###################################### Entry Point ####################################################
####################################################################################################
def main():
    # Setup to Receive Command Line Args
    parser = argparse.ArgumentParser(description="Build C Functions from Templates")
    parser.add_argument("--json", action="store", dest="template_json", required=True, help="Provide path to the JSON containing your function templates!")

    # Args list
    given_args = parser.parse_args()
    
    # Extract each argument
    json_path = given_args.template_json

    # Retreive JSON data as dictionary
    try:
        with open(json_path) as template_file:
            template_data = json.load(template_file)
    except Exception as exc:
        print_error_and_exit("Template File Exception: " + str(exc))

    # Convert JSON data into appropriate objects
    template_list = create_template_objects_from_json(template_data, get_file_name_from_path(json_path))

    # Generate Function Headers from Template Objects -- and APPEND to c & h files
    for template in template_list:
        func_headers = template.generate_function_header_list()
        output_functions_to_program_files(func_headers, template) # Write to C / H files accordingly


####################################################################################################
####################################################################################################
####################################################################################################

if __name__ == "__main__":
    main()

